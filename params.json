{"name":"code_hdu","tagline":"知行合一","body":"# Problem 1100\r\n\r\n[二叉树排序](http://blog.sohu.com/people/!Zm9nZ3lfZWxmQHNvaHUuY29t/79594466.html)\r\n\r\n# Problem 1102\r\nkruskal算法求最小生成树\r\n查询与合并使用并查集\r\n\r\n```c++\r\nint find(int x) {\r\n    return p[x] == x ? x : p[x] = find(p[x]);\r\n}\r\n```\r\n```c++\r\nvoid union(int a, int b) {\r\n    int x = find(a);\r\n    int y = find(y);\r\n    if (x != y) {\r\n        p[x] = y;\r\n     }\r\n}\r\n```\r\n\r\n# Problem 1103\r\n使用队列数组模拟排队\r\n\r\n ```c++\r\ndeque<int> q[3];\r\nq[i].push_back; // 入队\r\nq[i].pop_front; // 出队\r\n```\r\n\r\n\r\n# Problem 1104\r\n\r\n题意：（注意题目中的%是指mod）开始给了你n, k, m。。。。每次由+m, -m, *m, modm得到新的N，继续对N这样的操作,直到(n+1) mod k== N mod k时结束。。。并且打印路径\r\n\r\n%与mod的区别：%出来的数有正有负，符号取决于左操作数。。。而mod只能是正（因为a = b * q + r (q > 0 and 0 <= r < q), then we have a mod q = r 中r要大于等于0小于q）。。。。。\r\n\r\n所以要用%来计算mod的话就要用这样的公式：a mod b = (a % b + b) % b\r\n\r\n括号里的目的是把左操作数转成正数\r\n\r\n由于新的N可以很大，所以我们每一步都要取%，而且最后要mod k，正常来说每步都%k就行了，但是由于其中的一个操作是N%m,所以我们每一步就不能%k了（%k%m混用会导致%出来的答案错误），而要%(k *m);\r\n\r\n思路： 用BFS（广度优先搜索），找到的第一个解一定是离根最近的，缺点是空间开销大。每一步的状态是\r\n```\r\nn mod k ((n % k + k) %k)\r\n```\r\n\r\n\r\n\r\n# Problem 1107\r\n\r\n用一个结构体数组保存所有人，如果HP < 0 ，将代号变成0，而不是从数组中删除。题目的意思是一个格子只有两个人而且分属不同门派才战斗,其他情况跳过。\r\n> 当有两名不同门派的弟子进入同一个格子时，一定会发生一次战斗，而且也只有在这种情况下，才会发生战斗。（同派弟子之间当然不会自相残杀；一个格子里三派弟子都有时，大家都会因为害怕别人渔翁得利而不敢出手；而多名同门派弟子也不会联手对付敌人，因为这有悖于武林中崇尚的单打独斗精神，会被人耻笑）\r\n\r\n\r\n# Problem 1109\r\n\r\n使用模拟退火搜索最优解\r\n\r\n1. 初始化：初始温度T(充分大)，初始解状态S(是算法迭代的起点)，每个T值的迭代次数L\r\n2. 对k=1，……，L做第(3)至第(6)步：\r\n3. 产生新解S′\r\n4. 计算增量Δt′=C(S′)-C(S)，其中C(S)为评价函数\r\n5. 若Δt′<0则接受S′作为新的当前解，否则以概率exp(-Δt′/T)接受S′作为新的当前解.\r\n6. 如果满足终止条件则输出当前解作为最优解，结束程序。终止条件通常取为连续若干个新解都没有被接受时终止算法。\r\n8. T逐渐减少，且T->0，然后转第2步。\r\n\r\n#Problem 1556\r\n\r\n[树状数组](http://dongxicheng.org/structure/binary_indexed_tree/)\r\n\r\n#Problem 1207\r\n\r\n```cpp\r\n//四柱汉诺塔 Frame算法：\r\nf[n] = min(2 * f[n - r] + pow(2, r) - 1); // r = 1..n-1\r\n```\r\n[多柱汉诺塔](http://www.cnblogs.com/fanzhidongyzby/archive/2012/07/28/2613173.html)\r\n\r\n#Problem 1208\r\n\r\n```cpp\r\n//从矩阵左上角到右下角有多少种走法\r\n//可以直接更新或者dfs\r\n//long long dp[i][j]\r\ndp[i][j + a[i][j]] += dp[i][j];\r\ndp[i + a[i][j]][j] += dp[i][j];\r\n```\r\n[题目描述有问题](http://acm.hdu.edu.cn/discuss/problem/post/reply.php?postid=12037&messageid=1&deep=0)\r\n\r\n#Problem 1220\r\n```cpp\r\n//把一个边长为n的立方体切成n*n*n份，求相邻顶点数少于4个的小立方体的对数\r\n// C(2, n ^ 3) - 3 * (n - 1) * (n ^ 2): \r\n(n * n * n) * (n * n * n - 1) / 2 - 3 * (n * n) * (n - 1)\r\n```\r\n[详解](http://acm.hdu.edu.cn/discuss/problem/post/reply.php?postid=12958&messageid=1&deep=0)\r\n\r\n#Problem 1209\r\n```cpp\r\n//主要注意两点：1.角度相同，时间早的排在前面 2.角度<= 180\r\ndouble angle(int h, int m) {\r\n\tdouble d = abs(m * 6 - ((h % 12) * 30 + m * 0.5));\r\n\tif (d >= 180)\r\n\t\td = 360 -d;\r\n\treturn d;\r\n}\r\n\r\nint cmp (Ti a, Ti b) {\r\n\tif (abs(a.ang - b.ang) < 0.0001)\r\n\t\treturn a.h * 60 + a.m < b.h * 60 + b.m;\r\n\telse\r\n\t\treturn a.ang < b.ang;\r\n}\r\n```\r\n考虑问题的时候要认真仔细\r\n\r\n#Problem 1213\r\n```cpp\r\n//查找不相交数据集的个数\r\n//...已经使用并查集算法分好集合\r\nfor (int i = 1; i <= n; ++i)\r\n    if (p[i] == i)//如果是一个根节点，那么集合数加一\r\n        ++ans;\r\n```\r\n\r\n#Problem 1214\r\n```cpp\r\n//一个环123...n，每次两两交换，要几次才能变成n...321\r\n//分成两半交换\r\n//n = 2k: a[n] = sum(1..k-1) * 2 = k(k-1)\r\n//n = 2k - 1: a[n] = sum(1..k-1) + sum(1..k - 2) = (k-1)^2\r\n```\r\n\r\n#Problem 1273\r\n\r\n平面上有n个点，每两个点都相连，从一个点出发经过所有的点后回到这个点，而且没有重复的路径，问有几种走法？  \r\n \r\n每个点有n-1个点相邻，因为从一半的路径出发，从另一半返回，所以最多有(n - 1) / 2总走法。\r\n\r\n#Problem 1290\r\n\r\n求n个平面最多能划分几个空间（切球）\r\n\r\n假设能划分f(n)个空间，n条线能划分g(n)个区域：   \r\n一个面最多与其他n-1个面形成n-1条交线，这些交线最多能把平面切成g(n-1)个区域，从而多出g(n-1)个空间   \r\n所以f(n) = f(n - 1) + g(n-1)，而g(n) = g(n - 1) + n，推出f(n) = (n ^ 3 + 5 * n) / 6 + 1   \r\n\r\n[划分问题](http://blog.csdn.net/yangyafeiac/article/details/7828399)\r\n\r\n#Problem 1231\r\n\r\n最大子序列和\r\n\r\n从左到右遍历，要么继续一段序列，要么开始一段新序列。假设f是前一序列，那么 \r\n```\r\nf = max(f + a[i], a[i])\r\n````  \r\n如果 f 大于最大值，更新最大值和序列尾。 \r\n```\r\nans = max(ans, f)\r\n```\r\n最后求出序列开始的地方。\r\n\r\n#Problem 1292\r\n\r\n把一群人分成若干队，有几种分法？\r\n\r\n动态规划，i个人分成j队有两种可能：  \r\n1. i-1个人分成j-1队，第i个人自己成为一队；  \r\n2. i-1个人分成j队，第i个人分到其中一队。  \r\n```\r\na[i][j] = a[i - 1][j - 1] + a[i - 1][j] * j\r\n```\r\n\r\n#Problem 1293\r\n\r\n每一步只能向上、左、右移动，如果最后一次是左或者右，下一步只有两种移动方法，如果最后一次是上，下一步有三种移动方法。\r\n```cpp\r\na[i] = a[i - 1] * 2 + a[i - 2] //最后一次向上的数目为a[i - 2]\r\n```\r\n\r\n#Problem 1296\r\n\r\n多项式求和。这题的难点是如何处理输入  \r\n比如\r\n```\r\n1003X^5+234X^4-12X^3-2X^2+987X-1000\r\n```\r\n每一项可以分成符号+系数+参数+指数  \r\n\r\n#Problem 1297\r\n\r\n递推公式\r\n```\r\nF(n)=F(n-1)+F(n-2)+F(n-4)\r\n```\r\n1. 最后一个是M ，有F(n-1)种\r\n2. 最后一个是F ，根据题目意思，倒数第二个只能是F ，如果前n-2种是有效序列，有F(n-2)种\r\n3. 最后两个是FF ，但是前n-2种是无效序列，只有F(n-4) M F 这一种情况\r\n\r\n#Problem 1294\r\n\r\n重复组合\r\n\r\n>可以把该过程看作是一个“放球模型”；n个不同的元素看作是n个格子，去掉头尾之后中间一共有（n-1）块相同的隔板；用m个相同的小球代表取m次；则原问题可以简化为将m个不加区别的小球放进n个格子里面，问有多少种放法；注意到格子的头尾两块隔板无论什么情况下位置都是不变的，故去掉不用考虑。共有C(m, m + n - 1)种。","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}