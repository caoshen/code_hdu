<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="viewport" content="width=640" />

    <link rel="stylesheet" href="stylesheets/core.css" media="screen"/>
    <link rel="stylesheet" href="stylesheets/mobile.css" media="handheld, only screen and (max-device-width:640px)"/>
    <link rel="stylesheet" href="stylesheets/pygment_trac.css"/>

    <script type="text/javascript" src="javascripts/modernizr.js"></script>
    <script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
    <script type="text/javascript" src="javascripts/headsmart.min.js"></script>
    <script type="text/javascript">
      $(document).ready(function () {
        $('#main_content').headsmart()
      })
    </script>
    <title>code_hdu by caoshen</title>
  </head>

  <body>
    <a id="forkme_banner" href="https://github.com/caoshen/code_hdu">View on GitHub</a>
    <div class="shell">

      <header>
        <span class="ribbon-outer">
          <span class="ribbon-inner">
            <h1>code_hdu</h1>
            <h2>知行合一</h2>
          </span>
          <span class="left-tail"></span>
          <span class="right-tail"></span>
        </span>
      </header>

      <section id="downloads">
        <span class="inner">
          <a href="https://github.com/caoshen/code_hdu/zipball/master" class="zip"><em>download</em> .ZIP</a><a href="https://github.com/caoshen/code_hdu/tarball/master" class="tgz"><em>download</em> .TGZ</a>
        </span>
      </section>


      <span class="banner-fix"></span>


      <section id="main_content">
        <h1>
<a name="problem-1100" class="anchor" href="#problem-1100"><span class="octicon octicon-link"></span></a>Problem 1100</h1>

<p><a href="http://blog.sohu.com/people/!Zm9nZ3lfZWxmQHNvaHUuY29t/79594466.html">二叉树排序</a></p>

<h1>
<a name="problem-1102" class="anchor" href="#problem-1102"><span class="octicon octicon-link"></span></a>Problem 1102</h1>

<p>kruskal算法求最小生成树
查询与合并使用并查集</p>

<div class="highlight highlight-c++"><pre><span class="kt">int</span> <span class="nf">find</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">p</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">==</span> <span class="n">x</span> <span class="o">?</span> <span class="n">x</span> <span class="o">:</span> <span class="n">p</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="n">x</span><span class="p">]);</span>
<span class="p">}</span>
</pre></div>

<div class="highlight highlight-c++"><pre><span class="kt">void</span> <span class="nf">union</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">y</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">!=</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">p</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">y</span><span class="p">;</span>
     <span class="p">}</span>
<span class="p">}</span>
</pre></div>

<h1>
<a name="problem-1103" class="anchor" href="#problem-1103"><span class="octicon octicon-link"></span></a>Problem 1103</h1>

<p>使用队列数组模拟排队</p>

<div class="highlight highlight-c++"><pre><span class="n">deque</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">q</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
<span class="n">q</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">push_back</span><span class="p">;</span> <span class="c1">// 入队</span>
<span class="n">q</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">pop_front</span><span class="p">;</span> <span class="c1">// 出队</span>
</pre></div>

<h1>
<a name="problem-1104" class="anchor" href="#problem-1104"><span class="octicon octicon-link"></span></a>Problem 1104</h1>

<p>题意：（注意题目中的%是指mod）开始给了你n, k, m。。。。每次由+m, -m, *m, modm得到新的N，继续对N这样的操作,直到(n+1) mod k== N mod k时结束。。。并且打印路径</p>

<p>%与mod的区别：%出来的数有正有负，符号取决于左操作数。。。而mod只能是正（因为a = b * q + r (q &gt; 0 and 0 &lt;= r &lt; q), then we have a mod q = r 中r要大于等于0小于q）。。。。。</p>

<p>所以要用%来计算mod的话就要用这样的公式：a mod b = (a % b + b) % b</p>

<p>括号里的目的是把左操作数转成正数</p>

<p>由于新的N可以很大，所以我们每一步都要取%，而且最后要mod k，正常来说每步都%k就行了，但是由于其中的一个操作是N%m,所以我们每一步就不能%k了（%k%m混用会导致%出来的答案错误），而要%(k *m);</p>

<p>思路： 用BFS（广度优先搜索），找到的第一个解一定是离根最近的，缺点是空间开销大。每一步的状态是</p>

<pre><code>n mod k ((n % k + k) %k)
</code></pre>

<h1>
<a name="problem-1107" class="anchor" href="#problem-1107"><span class="octicon octicon-link"></span></a>Problem 1107</h1>

<p>用一个结构体数组保存所有人，如果HP &lt; 0 ，将代号变成0，而不是从数组中删除。题目的意思是一个格子只有两个人而且分属不同门派才战斗,其他情况跳过。</p>

<blockquote>
<p>当有两名不同门派的弟子进入同一个格子时，一定会发生一次战斗，而且也只有在这种情况下，才会发生战斗。（同派弟子之间当然不会自相残杀；一个格子里三派弟子都有时，大家都会因为害怕别人渔翁得利而不敢出手；而多名同门派弟子也不会联手对付敌人，因为这有悖于武林中崇尚的单打独斗精神，会被人耻笑）</p>
</blockquote>

<h1>
<a name="problem-1109" class="anchor" href="#problem-1109"><span class="octicon octicon-link"></span></a>Problem 1109</h1>

<p>使用模拟退火搜索最优解</p>

<ol>
<li>初始化：初始温度T(充分大)，初始解状态S(是算法迭代的起点)，每个T值的迭代次数L</li>
<li>对k=1，……，L做第(3)至第(6)步：</li>
<li>产生新解S′</li>
<li>计算增量Δt′=C(S′)-C(S)，其中C(S)为评价函数</li>
<li>若Δt′&lt;0则接受S′作为新的当前解，否则以概率exp(-Δt′/T)接受S′作为新的当前解.</li>
<li>如果满足终止条件则输出当前解作为最优解，结束程序。终止条件通常取为连续若干个新解都没有被接受时终止算法。</li>
<li>T逐渐减少，且T-&gt;0，然后转第2步。</li>
</ol><h1>
<a name="problem-1556" class="anchor" href="#problem-1556"><span class="octicon octicon-link"></span></a>Problem 1556</h1>

<p><a href="http://dongxicheng.org/structure/binary_indexed_tree/">树状数组</a></p>

<h1>
<a name="problem-1207" class="anchor" href="#problem-1207"><span class="octicon octicon-link"></span></a>Problem 1207</h1>

<div class="highlight highlight-cpp"><pre><span class="c1">//四柱汉诺塔 Frame算法：</span>
<span class="n">f</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">f</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="n">r</span><span class="p">]</span> <span class="o">+</span> <span class="n">pow</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">// r = 1..n-1</span>
</pre></div>

<p><a href="http://www.cnblogs.com/fanzhidongyzby/archive/2012/07/28/2613173.html">多柱汉诺塔</a></p>

<h1>
<a name="problem-1208" class="anchor" href="#problem-1208"><span class="octicon octicon-link"></span></a>Problem 1208</h1>

<div class="highlight highlight-cpp"><pre><span class="c1">//从矩阵左上角到右下角有多少种走法</span>
<span class="c1">//可以直接更新或者dfs</span>
<span class="c1">//long long dp[i][j]</span>
<span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span> <span class="o">+</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]]</span> <span class="o">+=</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
<span class="n">dp</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]][</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
</pre></div>

<p><a href="http://acm.hdu.edu.cn/discuss/problem/post/reply.php?postid=12037&amp;messageid=1&amp;deep=0">题目描述有问题</a></p>

<h1>
<a name="problem-1220" class="anchor" href="#problem-1220"><span class="octicon octicon-link"></span></a>Problem 1220</h1>

<div class="highlight highlight-cpp"><pre><span class="c1">//把一个边长为n的立方体切成n*n*n份，求相邻顶点数少于4个的小立方体的对数</span>
<span class="c1">// C(2, n ^ 3) - 3 * (n - 1) * (n ^ 2): </span>
<span class="p">(</span><span class="n">n</span> <span class="o">*</span> <span class="n">n</span> <span class="o">*</span> <span class="n">n</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span> <span class="o">*</span> <span class="n">n</span> <span class="o">*</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">3</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span> <span class="o">*</span> <span class="n">n</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>

<p><a href="http://acm.hdu.edu.cn/discuss/problem/post/reply.php?postid=12958&amp;messageid=1&amp;deep=0">详解</a></p>

<h1>
<a name="problem-1209" class="anchor" href="#problem-1209"><span class="octicon octicon-link"></span></a>Problem 1209</h1>

<div class="highlight highlight-cpp"><pre><span class="c1">//主要注意两点：1.角度相同，时间早的排在前面 2.角度&lt;= 180</span>
<span class="kt">double</span> <span class="nf">angle</span><span class="p">(</span><span class="kt">int</span> <span class="n">h</span><span class="p">,</span> <span class="kt">int</span> <span class="n">m</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">double</span> <span class="n">d</span> <span class="o">=</span> <span class="n">abs</span><span class="p">(</span><span class="n">m</span> <span class="o">*</span> <span class="mi">6</span> <span class="o">-</span> <span class="p">((</span><span class="n">h</span> <span class="o">%</span> <span class="mi">12</span><span class="p">)</span> <span class="o">*</span> <span class="mi">30</span> <span class="o">+</span> <span class="n">m</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">));</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">d</span> <span class="o">&gt;=</span> <span class="mi">180</span><span class="p">)</span>
        <span class="n">d</span> <span class="o">=</span> <span class="mi">360</span> <span class="o">-</span><span class="n">d</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">d</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">cmp</span> <span class="p">(</span><span class="n">Ti</span> <span class="n">a</span><span class="p">,</span> <span class="n">Ti</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">abs</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">ang</span> <span class="o">-</span> <span class="n">b</span><span class="p">.</span><span class="n">ang</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">0.0001</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">a</span><span class="p">.</span><span class="n">h</span> <span class="o">*</span> <span class="mi">60</span> <span class="o">+</span> <span class="n">a</span><span class="p">.</span><span class="n">m</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">.</span><span class="n">h</span> <span class="o">*</span> <span class="mi">60</span> <span class="o">+</span> <span class="n">b</span><span class="p">.</span><span class="n">m</span><span class="p">;</span>
    <span class="k">else</span>
        <span class="k">return</span> <span class="n">a</span><span class="p">.</span><span class="n">ang</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">.</span><span class="n">ang</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>

<p>考虑问题的时候要认真仔细</p>

<h1>
<a name="problem-1213" class="anchor" href="#problem-1213"><span class="octicon octicon-link"></span></a>Problem 1213</h1>

<div class="highlight highlight-cpp"><pre><span class="c1">//查找不相交数据集的个数</span>
<span class="c1">//...已经使用并查集算法分好集合</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">i</span><span class="p">)</span><span class="c1">//如果是一个根节点，那么集合数加一</span>
        <span class="o">++</span><span class="n">ans</span><span class="p">;</span>
</pre></div>

<h1>
<a name="problem-1214" class="anchor" href="#problem-1214"><span class="octicon octicon-link"></span></a>Problem 1214</h1>

<div class="highlight highlight-cpp"><pre><span class="c1">//一个环123...n，每次两两交换，要几次才能变成n...321</span>
<span class="c1">//分成两半交换</span>
<span class="c1">//n = 2k: a[n] = sum(1..k-1) * 2 = k(k-1)</span>
<span class="c1">//n = 2k - 1: a[n] = sum(1..k-1) + sum(1..k - 2) = (k-1)^2</span>
</pre></div>

<h1>
<a name="problem-1273" class="anchor" href="#problem-1273"><span class="octicon octicon-link"></span></a>Problem 1273</h1>

<p>平面上有n个点，每两个点都相连，从一个点出发经过所有的点后回到这个点，而且没有重复的路径，问有几种走法？  </p>

<p>每个点有n-1个点相邻，因为从一半的路径出发，从另一半返回，所以最多有(n - 1) / 2总走法。</p>

<h1>
<a name="problem-1290" class="anchor" href="#problem-1290"><span class="octicon octicon-link"></span></a>Problem 1290</h1>

<p>求n个平面最多能划分几个空间（切球）</p>

<p>假设能划分f(n)个空间，n条线能划分g(n)个区域：<br>
一个面最多与其他n-1个面形成n-1条交线，这些交线最多能把平面切成g(n-1)个区域，从而多出g(n-1)个空间<br>
所以f(n) = f(n - 1) + g(n-1)，而g(n) = g(n - 1) + n，推出f(n) = (n ^ 3 + 5 * n) / 6 + 1   </p>

<p><a href="http://blog.csdn.net/yangyafeiac/article/details/7828399">划分问题</a></p>

<h1>
<a name="problem-1231" class="anchor" href="#problem-1231"><span class="octicon octicon-link"></span></a>Problem 1231</h1>

<p>最大子序列和</p>

<p>从左到右遍历，要么继续一段序列，要么开始一段新序列。假设f是前一序列，那么 </p>

<pre><code>f = max(f + a[i], a[i])
</code></pre>

<p>如果 f 大于最大值，更新最大值和序列尾。 </p>

<pre><code>ans = max(ans, f)
</code></pre>

<p>最后求出序列开始的地方。</p>

<h1>
<a name="problem-1292" class="anchor" href="#problem-1292"><span class="octicon octicon-link"></span></a>Problem 1292</h1>

<p>把一群人分成若干队，有几种分法？</p>

<p>动态规划，i个人分成j队有两种可能：<br>
1. i-1个人分成j-1队，第i个人自己成为一队；<br>
2. i-1个人分成j队，第i个人分到其中一队。  </p>

<pre><code>a[i][j] = a[i - 1][j - 1] + a[i - 1][j] * j
</code></pre>

<h1>
<a name="problem-1293" class="anchor" href="#problem-1293"><span class="octicon octicon-link"></span></a>Problem 1293</h1>

<p>每一步只能向上、左、右移动，如果最后一次是左或者右，下一步只有两种移动方法，如果最后一次是上，下一步有三种移动方法。</p>

<div class="highlight highlight-cpp"><pre><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">2</span><span class="p">]</span> <span class="c1">//最后一次向上的数目为a[i - 2]</span>
</pre></div>

<h1>
<a name="problem-1296" class="anchor" href="#problem-1296"><span class="octicon octicon-link"></span></a>Problem 1296</h1>

<p>多项式求和。这题的难点是如何处理输入<br>
比如</p>

<pre><code>1003X^5+234X^4-12X^3-2X^2+987X-1000
</code></pre>

<p>每一项可以分成符号+系数+参数+指数  </p>

<h1>
<a name="problem-1297" class="anchor" href="#problem-1297"><span class="octicon octicon-link"></span></a>Problem 1297</h1>

<p>递推公式</p>

<pre><code>F(n)=F(n-1)+F(n-2)+F(n-4)
</code></pre>

<ol>
<li>最后一个是M ，有F(n-1)种</li>
<li>最后一个是F ，根据题目意思，倒数第二个只能是F ，如果前n-2种是有效序列，有F(n-2)种</li>
<li>最后两个是FF ，但是前n-2种是无效序列，只有F(n-4) M F 这一种情况</li>
</ol><h1>
<a name="problem-1294" class="anchor" href="#problem-1294"><span class="octicon octicon-link"></span></a>Problem 1294</h1>

<p>看图可以知道 f(5) = f(4) + f(3)f(1) + f(2)f(2) + f(1)f(1)f(2) + f(1)f(1)f(1)f(1)<br>
所以要求出 n-1 的拆分数，这种拆分是可重复的，拆分的过程使用dfs  </p>

<p><strong>重复组合</strong></p>

<blockquote>
<p>可以把该过程看作是一个“放球模型”；n个不同的元素看作是n个格子，去掉头尾之后中间一共有（n-1）块相同的隔板；用m个相同的小球代表取m次；则原问题可以简化为将m个不加区别的小球放进n个格子里面，问有多少种放法；注意到格子的头尾两块隔板无论什么情况下位置都是不变的，故去掉不用考虑。共有C(m, m + n - 1)种。</p>
</blockquote>

<h1>
<a name="problem-1198" class="anchor" href="#problem-1198"><span class="octicon octicon-link"></span></a>Problem 1198</h1>

<p>使用并查集求不相交数据集的个数，union 的是二维数组中相邻而且相连的元素。<br>
union的时候考虑左和上两个方向，同一条线上不用同时考虑两边。</p>

<h1>
<a name="problem-1264" class="anchor" href="#problem-1264"><span class="octicon octicon-link"></span></a>Problem 1264</h1>

<p>求几个长方形的总面积，考虑覆盖情况<br>
可以把整个平面范围看成一些点，如果一个点在矩形中，就标记为已经覆盖。最后遍历所有的点。</p>
      </section>

      <footer>
        <span class="ribbon-outer">
          <span class="ribbon-inner">
            <p>this project by <a href="https://github.com/caoshen">caoshen</a> can be found on <a href="https://github.com/caoshen/code_hdu">GitHub</a></p>
          </span>
          <span class="left-tail"></span>
          <span class="right-tail"></span>
        </span>
        <p>Generated with <a href="http://pages.github.com">GitHub Pages</a> using Merlot</p>
        <span class="octocat"></span>
      </footer>

    </div>

    
  </body>
</html>
