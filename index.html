<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>code_hdu by caoshen</title>
    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
    <script src="javascripts/main.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

  </head>
  <body>

      <header>
        <h1>code_hdu</h1>
        <p>知行合一</p>
      </header>

      <div id="banner">
        <span id="logo"></span>

        <a href="https://github.com/caoshen/code_hdu" class="button fork"><strong>View On GitHub</strong></a>
        <div class="downloads">
          <span>Downloads:</span>
          <ul>
            <li><a href="https://github.com/caoshen/code_hdu/zipball/master" class="button">ZIP</a></li>
            <li><a href="https://github.com/caoshen/code_hdu/tarball/master" class="button">TAR</a></li>
          </ul>
        </div>
      </div><!-- end banner -->

    <div class="wrapper">
      <nav>
        <ul></ul>
      </nav>
      <section>
        <h1>
<a name="problem-1100" class="anchor" href="#problem-1100"><span class="octicon octicon-link"></span></a>Problem 1100</h1>

<p><a href="http://blog.sohu.com/people/!Zm9nZ3lfZWxmQHNvaHUuY29t/79594466.html">二叉树排序</a></p>

<h1>
<a name="problem-1102" class="anchor" href="#problem-1102"><span class="octicon octicon-link"></span></a>Problem 1102</h1>

<p>kruskal算法求最小生成树
查询与合并使用并查集</p>

<div class="highlight highlight-c++"><pre><span class="kt">int</span> <span class="nf">find</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">p</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">==</span> <span class="n">x</span> <span class="o">?</span> <span class="n">x</span> <span class="o">:</span> <span class="n">p</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="n">x</span><span class="p">]);</span>
<span class="p">}</span>
</pre></div>

<div class="highlight highlight-c++"><pre><span class="kt">void</span> <span class="nf">union</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">y</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">!=</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">p</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">y</span><span class="p">;</span>
     <span class="p">}</span>
<span class="p">}</span>
</pre></div>

<h1>
<a name="problem-1103" class="anchor" href="#problem-1103"><span class="octicon octicon-link"></span></a>Problem 1103</h1>

<p>使用队列数组模拟排队</p>

<div class="highlight highlight-c++"><pre><span class="n">deque</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">q</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
<span class="n">q</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">push_back</span><span class="p">;</span> <span class="c1">// 入队</span>
<span class="n">q</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">pop_front</span><span class="p">;</span> <span class="c1">// 出队</span>
</pre></div>

<h1>
<a name="problem-1104" class="anchor" href="#problem-1104"><span class="octicon octicon-link"></span></a>Problem 1104</h1>

<p>题意：（注意题目中的%是指mod）开始给了你n, k, m。。。。每次由+m, -m, *m, modm得到新的N，继续对N这样的操作,直到(n+1) mod k== N mod k时结束。。。并且打印路径</p>

<p>%与mod的区别：%出来的数有正有负，符号取决于左操作数。。。而mod只能是正（因为a = b * q + r (q &gt; 0 and 0 &lt;= r &lt; q), then we have a mod q = r 中r要大于等于0小于q）。。。。。</p>

<p>所以要用%来计算mod的话就要用这样的公式：a mod b = (a % b + b) % b</p>

<p>括号里的目的是把左操作数转成正数</p>

<p>由于新的N可以很大，所以我们每一步都要取%，而且最后要mod k，正常来说每步都%k就行了，但是由于其中的一个操作是N%m,所以我们每一步就不能%k了（%k%m混用会导致%出来的答案错误），而要%(k *m);</p>

<p>思路： 用BFS（广度优先搜索），找到的第一个解一定是离根最近的，缺点是空间开销大。每一步的状态是<code>n mod k ((n % k + k) %k)</code></p>

<h1>
<a name="problem-1107" class="anchor" href="#problem-1107"><span class="octicon octicon-link"></span></a>Problem 1107</h1>

<p>用一个结构体数组保存所有人，如果HP &lt; 0 ，将代号变成0，而不是从数组中删除。题目的意思是一个格子只有两个人而且分属不同门派才战斗,其他情况跳过。</p>

<blockquote>
<p>当有两名不同门派的弟子进入同一个格子时，一定会发生一次战斗，而且也只有在这种情况下，才会发生战斗。（同派弟子之间当然不会自相残杀；一个格子里三派弟子都有时，大家都会因为害怕别人渔翁得利而不敢出手；而多名同门派弟子也不会联手对付敌人，因为这有悖于武林中崇尚的单打独斗精神，会被人耻笑）</p>
</blockquote>

<h1>
<a name="problem-1109" class="anchor" href="#problem-1109"><span class="octicon octicon-link"></span></a>Problem 1109</h1>

<p>使用模拟退火搜索最优解</p>

<ol>
<li>初始化：初始温度T(充分大)，初始解状态S(是算法迭代的起点)，每个T值的迭代次数L</li>
<li>对k=1，……，L做第(3)至第(6)步：</li>
<li>产生新解S′</li>
<li>计算增量Δt′=C(S′)-C(S)，其中C(S)为评价函数</li>
<li>若Δt′&lt;0则接受S′作为新的当前解，否则以概率exp(-Δt′/T)接受S′作为新的当前解.</li>
<li>如果满足终止条件则输出当前解作为最优解，结束程序。终止条件通常取为连续若干个新解都没有被接受时终止算法。</li>
<li>T逐渐减少，且T-&gt;0，然后转第2步。</li>
</ol><h1>
<a name="problem-1556" class="anchor" href="#problem-1556"><span class="octicon octicon-link"></span></a>Problem 1556</h1>

<p><a href="http://dongxicheng.org/structure/binary_indexed_tree/">树状数组</a></p>

<h1>
<a name="problem-1207" class="anchor" href="#problem-1207"><span class="octicon octicon-link"></span></a>Problem 1207</h1>

<div class="highlight highlight-cpp"><pre><span class="c1">//四柱汉诺塔 Frame算法：</span>
<span class="n">f</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">f</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="n">r</span><span class="p">]</span> <span class="o">+</span> <span class="n">pow</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">// r = 1..n-1</span>
</pre></div>

<p><a href="http://www.cnblogs.com/fanzhidongyzby/archive/2012/07/28/2613173.html">多柱汉诺塔</a></p>

<h1>
<a name="problem-1208" class="anchor" href="#problem-1208"><span class="octicon octicon-link"></span></a>Problem 1208</h1>

<div class="highlight highlight-cpp"><pre><span class="c1">//从矩阵左上角到右下角有多少种走法</span>
<span class="c1">//可以直接更新或者dfs</span>
<span class="c1">//long long dp[i][j]</span>
<span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span> <span class="o">+</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]]</span> <span class="o">+=</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
<span class="n">dp</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]][</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="n">dp</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">];</span>
</pre></div>

<p><a href="http://acm.hdu.edu.cn/discuss/problem/post/reply.php?postid=12037&amp;messageid=1&amp;deep=0">题目描述有问题</a></p>

<h1>
<a name="problem-1220" class="anchor" href="#problem-1220"><span class="octicon octicon-link"></span></a>Problem 1220</h1>

<div class="highlight highlight-cpp"><pre><span class="c1">//把一个边长为n的立方体切成n*n*n份，求相邻顶点数少于4个的小立方体的对数</span>
<span class="c1">// C(2, n ^ 3) - 3 * (n - 1) * (n ^ 2): </span>
<span class="p">(</span><span class="n">n</span> <span class="o">*</span> <span class="n">n</span> <span class="o">*</span> <span class="n">n</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span> <span class="o">*</span> <span class="n">n</span> <span class="o">*</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">3</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span> <span class="o">*</span> <span class="n">n</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>

<p><a href="http://acm.hdu.edu.cn/discuss/problem/post/reply.php?postid=12958&amp;messageid=1&amp;deep=0">详解</a></p>

<h1>
<a name="problem-1209" class="anchor" href="#problem-1209"><span class="octicon octicon-link"></span></a>Problem 1209</h1>

<div class="highlight highlight-cpp"><pre><span class="c1">//主要注意两点：1.角度相同，时间早的排在前面 2.角度&lt;= 180</span>
<span class="kt">double</span> <span class="nf">angle</span><span class="p">(</span><span class="kt">int</span> <span class="n">h</span><span class="p">,</span> <span class="kt">int</span> <span class="n">m</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">double</span> <span class="n">d</span> <span class="o">=</span> <span class="n">abs</span><span class="p">(</span><span class="n">m</span> <span class="o">*</span> <span class="mi">6</span> <span class="o">-</span> <span class="p">((</span><span class="n">h</span> <span class="o">%</span> <span class="mi">12</span><span class="p">)</span> <span class="o">*</span> <span class="mi">30</span> <span class="o">+</span> <span class="n">m</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">));</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">d</span> <span class="o">&gt;=</span> <span class="mi">180</span><span class="p">)</span>
        <span class="n">d</span> <span class="o">=</span> <span class="mi">360</span> <span class="o">-</span><span class="n">d</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">d</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">cmp</span> <span class="p">(</span><span class="n">Ti</span> <span class="n">a</span><span class="p">,</span> <span class="n">Ti</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">abs</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">ang</span> <span class="o">-</span> <span class="n">b</span><span class="p">.</span><span class="n">ang</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">0.0001</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">a</span><span class="p">.</span><span class="n">h</span> <span class="o">*</span> <span class="mi">60</span> <span class="o">+</span> <span class="n">a</span><span class="p">.</span><span class="n">m</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">.</span><span class="n">h</span> <span class="o">*</span> <span class="mi">60</span> <span class="o">+</span> <span class="n">b</span><span class="p">.</span><span class="n">m</span><span class="p">;</span>
    <span class="k">else</span>
        <span class="k">return</span> <span class="n">a</span><span class="p">.</span><span class="n">ang</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">.</span><span class="n">ang</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>

<p>考虑问题的时候要认真仔细</p>

<h1>
<a name="problem-1213" class="anchor" href="#problem-1213"><span class="octicon octicon-link"></span></a>Problem 1213</h1>

<div class="highlight highlight-cpp"><pre><span class="c1">//查找不相交数据集的个数</span>
<span class="c1">//...已经使用并查集算法分好集合</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">i</span><span class="p">)</span><span class="c1">//如果是一个根节点，那么集合数加一</span>
        <span class="o">++</span><span class="n">ans</span><span class="p">;</span>
</pre></div>

<h1>
<a name="problem-1214" class="anchor" href="#problem-1214"><span class="octicon octicon-link"></span></a>Problem 1214</h1>

<div class="highlight highlight-cpp"><pre><span class="c1">//一个环123...n，每次两两交换，要几次才能变成n...321</span>
<span class="c1">//分成两半交换</span>
<span class="c1">//n = 2k: a[n] = sum(1..k-1) * 2 = k(k-1)</span>
<span class="c1">//n = 2k - 1: a[n] = sum(1..k-1) + sum(1..k - 2) = (k-1)^2</span>
</pre></div>

<h1>
<a name="problem-1273" class="anchor" href="#problem-1273"><span class="octicon octicon-link"></span></a>Problem 1273</h1>

<p>平面上有n个点，每两个点都相连，从一个点出发经过所有的点后回到这个点，而且没有重复的路径，问有几种走法？  </p>

<p>每个点有n-1个点相邻，因为从一半的路径出发，从另一半返回，所以最多有(n - 1) / 2总走法。</p>
      </section>
      <footer>
        <p>Project maintained by <a href="https://github.com/caoshen">caoshen</a></p>
        <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://twitter.com/michigangraham">mattgraham</a></small></p>
      </footer>
    </div>
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->
    
  </body>
</html>