<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>code_hdu by caoshen</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1>code_hdu</h1>
        <p>知行合一</p>

        <p class="view"><a href="https://github.com/caoshen/code_hdu">View the Project on GitHub <small>caoshen/code_hdu</small></a></p>


        <ul>
          <li><a href="https://github.com/caoshen/code_hdu/zipball/master">Download <strong>ZIP File</strong></a></li>
          <li><a href="https://github.com/caoshen/code_hdu/tarball/master">Download <strong>TAR Ball</strong></a></li>
          <li><a href="https://github.com/caoshen/code_hdu">View On <strong>GitHub</strong></a></li>
        </ul>
      </header>
      <section>
        <h3>
<a name="what-does-hdoj-stand-for-" class="anchor" href="#what-does-hdoj-stand-for-"><span class="octicon octicon-link"></span></a>What does "HDOJ" stand for ?</h3>

<p>A HDOJ is short for Hangzhou Dianzi University Online Judge which was founded in September 2005 and has the lastest version of 3.0..</p>

<h3>
<a name="problem-1100" class="anchor" href="#problem-1100"><span class="octicon octicon-link"></span></a>Problem 1100</h3>

<p><a href="http://blog.sohu.com/people/!Zm9nZ3lfZWxmQHNvaHUuY29t/79594466.html">http://blog.sohu.com/people/!Zm9nZ3lfZWxmQHNvaHUuY29t/79594466.html</a></p>

<p>执行步骤：</p>

<p>首先，我们必须根据输入的N确定结点数node和子编号数index.</p>

<p>假设node个节点的树一共有A[node]棵，我们可以用一个数组A[0..MAXNODE]来存放这些量，那么：</p>

<p>A[0] = 1;</p>

<p>A[1] = 1;</p>

<p>A[2] = A[0] * A[1] + A[1] * A[0] = 2;  // 其中每一个项表示左右子树结点数的不同组合</p>

<p>A[3] = A[0] * A[2] + A[1] * A[1] + A[3] * A[0];</p>

<p>...</p>

<p>;</p>

<p>这样可以确定A，同时，建立数组B，B[node]为A的累加，表示node个节点以下的树一共有多少棵。根据搜索N在B[node]中的区间，可以确定节点数，同时，题目说明最大的编号不超过500,000,000，这样通过实验的方法求出MAXNODE = 19就够了。</p>

<p>计算出的A、B序列大致如下：</p>

<p>node =    [      0     1     2     3     4     5     ...    ]</p>

<p>A =               [      1     1     2     5     14    42    ...    ]</p>

<p>B =         [      1     2     4     9     23    65    ...    ]</p>

<p>例如，我们现在输入N = 55</p>

<p>那么可以看到B[4] &lt;= N &lt; B[5]，于是可以断言这棵树有5个节点，并且他是第N – B[4]个具有5个节点的树，也就是说：node = 5, index = 55 – 23 = 22;</p>

<p>我们设定一个返回string的函数：</p>

<p>string tree( int node, int index );</p>

<p>这个例子的结果就是调用：</p>

<p>cout &lt;&lt; tree(5, 22) &lt;&lt; endl;</p>

<p>在这个函数里面，我们将index按照这样的顺序搜索。</p>

<p>因为在同样具有node = 5的所有树里面，最开始是A[0] * A[4] = 14种L = 0，R = 4的组合，因为22 &gt;= 14，所以不是这种组合，我们将index变成22 – 14 = 6；然后是A[1] * A[3] = 5种L = 1，R = 3的组合，因为6 &gt;= 5，所以也不是这种组合，index = 6 – 5 = 1；然后是A[2] * A[2] = 4种L = R = 2的组合，而1 &lt; 4，因此求得这个编号的树为左子树节点为i = 2，右节点为j = 2的形式，并且为这种形式的第i种。</p>

<p>然后我们必须确定左子树是第几种node = 2的树(indexL)，右子树是第几种node = 2 的树(indexR)。</p>

<p>按照题目的规律，第0种i = j = 2的情况应该对应于indexL = 0，indexR = 0的情况，第1种i = j = 2的情况应该对应于indexL = 0，indexR = 1的情况。</p>

<p>那么，普遍地说，当任意的左子树结点数为i，右子树结点数为j的第index种组合，它的左子树序号应该为indexL = index / A[i]，右子树序号应该为indexR = index % A[i]；</p>

<p>于是，可以递归的调用tree()函数：</p>

<p>return tree(i, indexL) + ‘X’ + tree(j,indexR) 来获得上一级的字符串。</p>

<p>当然实际的程序要考虑到左子树或右子树为空的情况，来决定是否打上括号。并且递归的退出条件要适当斟酌。</p>

<p>具体请参看代码。</p>

<h3>
<a name="problem-1102" class="anchor" href="#problem-1102"><span class="octicon octicon-link"></span></a>Problem 1102</h3>

<p>kruskal算法求最小生成树
查询与合并使用并查集</p>

<div class="highlight highlight-c++"><pre><span class="kt">int</span> <span class="nf">find</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">p</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">==</span> <span class="n">x</span> <span class="o">?</span> <span class="n">x</span> <span class="o">:</span> <span class="n">p</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="n">x</span><span class="p">]);</span>
<span class="p">}</span>
</pre></div>

<div class="highlight highlight-c++"><pre><span class="kt">void</span> <span class="nf">union</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">y</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">!=</span> <span class="n">y</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">p</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">y</span><span class="p">;</span>
     <span class="p">}</span>
<span class="p">}</span>
</pre></div>
      </section>
      <footer>
        <p>This project is maintained by <a href="https://github.com/caoshen">caoshen</a></p>
        <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></small></p>
      </footer>
    </div>
    <script src="javascripts/scale.fix.js"></script>
    
  </body>
</html>